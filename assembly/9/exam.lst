     1                                  ;start:
     2                                  		; 计算378除以37的结果
     3                                  ;		mov ax, 378 ;被除数
     4                                  ;		mov bl, 37	;除数
     5                                  ;		div bl ;AL=商（10），AH=余数（8）
     6                                  	
     7                                  ;current:
     8                                  ;		times 510-(current-start) db 0
     9                                  ;		db 0x55,0xaa
    10                                  		
    11                                  		
    12                                  		
    13                                  ; 高位运算
    14                                  ;start:
    15                                  		; 计算65535除以10的结果
    16                                  ;		mov dx, 0
    17                                  ;		mov ax, 65535 ;被除数 ax是16位的 最大就是65535
    18                                  ;		mov bx, 10	;除数
    19                                  ;		div bx ;AX=商（6553），DX=余数（5）
    20                                  		
    21                                  		;div bl AL=商（6553），AH=余数（5） 这里al寄存器是8位的无法容纳6553 只能到255，所以要改成上面那行 div bx
    22                                  		
    23                                  		;上面这些指令是 将dx+ax的结果合并形成一个32位的二进制数就是 0000，0000，0000，0000，1111，1111，1111，1111 除以 bx 的内容，ax=商（6553），DX=余数（5）
    24                                  		
    25                                  	
    26                                  ;current:
    27                                  ;		times 510-(current-start) db 0
    28                                  ;		db 0x55,0xaa
    29                                  
    30                                  ; xor（异或）
    31                                  ;start:
    32                                  		; 计算65535除以10的结果
    33                                  ;		xor dx, dx ;当这条指令执行后 dx的内容也是0，自己和自己的异或 意味着2个二进制异或bit相同 也就是全部bit都是0 用来覆盖dx的内容 所以dx=0 等价于mov dx，0，这里为什么要用异或 xor？ 因为他2个操作数都是寄存器 因此执行起来比较快 比mov dx，0 要快
    34                                  ;		mov ax, 65535 ;被除数 ax是16位的 最大就是65535
    35                                  ;		mov bx, 10	;除数
    36                                  ;		div bx ;AX=商（6553），DX=余数（5）
    37                                  
    38                                  ;current:
    39                                  ;		times 510-(current-start) db 0
    40                                  ;		db 0x55,0xaa
    41                                  		
    42                                  		
    43                                  ; add
    44                                  start:
    45                                  		;在屏幕上显示数字65535，要显示65535需要先分解每一个数位
    46 00000000 B8FFFF                  		mov ax, 65535
    47 00000003 31D2                    		xor dx, dx		; 等价于mov dx, 0
    48 00000005 BB0A00                  		mov bx, 10
    49 00000008 F7F3                    		div bx			; AX=商（6553），dx=余数（5）其实是存在dl低8位的
    50                                  		
    51 0000000A 80C230                  		add dl, 0x30 	;将数字转换为对应的字符0x30+1-9 都可以，这里为什么加dl呢？因为dx16位 要取低位的dl
    52                                  		
    53                                  		;要访问数据必须使用数据段寄存器ds，所以下面这一段是把ds寄存器清0
    54 0000000D B90000                  		mov cx, 0 ; 这里是吧0放到cx
    55 00000010 8ED9                    		mov ds, cx ; 这里是把cx放到ds 因为 ds不接收立即数 所以需要借用cx寄存器
    56                                  		
    57 00000012 8816[8A7C]              		mov [0x7c00+buffer], dl ; 吧dl的字符编码放到buffer的第一个字节。 物理地址 = DS << 4 + offset = 0 << 4 + 0x7c00 + buffer = 0x7c00 + buffer 相当于buffer的第一个字节
    58                                  		
    59                                  		
    60 00000016 31D2                    		xor dx, dx ; 异或操作进行清零因为dx余数已经被放到buffer的第一个字节
    61 00000018 F7F3                    		div bx ; 继续进行除法运算 这个时候 AX=商(6553), DX=余数（0） BX=除数（10）所以= 6553 / 10 =  655（商） 3 = 余数
    62 0000001A 80C230                  		add dl, 0x30 ;把bl结果 进行转化为字符
    63 0000001D 8816[8B7C]              		mov [0x7c00+buffer+1], dl ; 吧dl内容放到buffer第二个字节 
    64                                  		
    65 00000021 31D2                    		xor dx, dx
    66 00000023 F7F3                    		div bx ; 继续进行除法运算 这个时候 AX=商(655), DX=余数（0） BX=除数（10）所以= 655 / 10 =  65（商） 5 = 余数
    67 00000025 80C230                  		add dl, 0x30 
    68 00000028 8816[8C7C]              		mov [0x7c00+buffer+2], dl 
    69                                  		
    70 0000002C 31D2                    		xor dx, dx
    71 0000002E F7F3                    		div bx ; 继续进行除法运算 这个时候 AX=商(65), DX=余数（0） BX=除数（10）所以= 65 / 10 =  6（商） 5 = 余数
    72 00000030 80C230                  		add dl, 0x30 
    73 00000033 8816[8D7C]              		mov [0x7c00+buffer+3], dl 
    74                                  		
    75 00000037 31D2                    		xor dx, dx
    76 00000039 F7F3                    		div bx ; 继续进行除法运算 这个时候 AX=商(6), DX=余数（0） BX=除数（10）所以= 65 / 10 =  0（商） 6 = 余数
    77 0000003B 80C230                  		add dl, 0x30 
    78 0000003E 8816[8E7C]              		mov [0x7c00+buffer+4], dl 
    79                                  		
    80                                  ;		mov al, [0x7c00+buffer+4] ;把buffer的第五个字节传到al寄存器
    81                                  		
    82                                  ;		mov cx, 0xb800 ; 这个是显存地址的开始 和上面一样需要中转传输 不能直接mov ds,0 
    83                                  ;		mov ds,cx
    84                                  		
    85                                  ;		mov [0x00], al ; 吧al寄存器里面的字传输的显存的偏移地址0x00开始处 这里是0xb800的偏移地址
    86                                  ;		mov byte [0x01], 0x2f ; 写入颜色绿色背景 亮白色 这个是立即数看不出内存大小 所以需要byte修饰
    87                                  		
    88                                  		; 这里因为ds段寄存器已经被改为显存的地址 所以需要改回来 改为磁盘引导扇区地址
    89                                  ;		mov cx, 0
    90                                  ;		mov ds, cx
    91                                  		
    92                                  ;		mov al, [0x7c00+buffer+3]
    93                                  		
    94                                  		; 写入显存还需要把段地址设置为显存地址 0xb800
    95                                  ;		mov cx,  0xb800
    96                                  ;		mov ds, cx
    97                                  		
    98                                  ;		mov [0x02], al
    99                                  ;		mov byte[0x03], 0x2f
   100                                  		
   101                                  		; 上面代码太复杂，需要用ds段寄存器反复切换，这里引入es扩展的段寄存器
   102 00000042 B900B8                  		mov cx, 0xb800
   103 00000045 8EC1                    		mov es, cx
   104                                  		
   105                                  		; 这里如果没有特别指明 是默认使用ds段寄存器的地址
   106 00000047 A0[8E7C]                		mov al, [0x7c00+buffer+4]
   107 0000004A 26A20000                		mov [es:0x00], al ; 这里es: 叫段超越前缀，如果没有这个默认是ds:0x00 使用了es: 则使用es扩展段寄存器
   108 0000004E 26C60601002F            		mov byte [es:0x01], 0x2f
   109                                  		
   110 00000054 A0[8D7C]                		mov al, [0x7c00+buffer+3]
   111 00000057 26A20200                		mov [es:0x02], al
   112 0000005B 26C60603002F            		mov byte [es:0x03], 0x2f
   113                                  		
   114 00000061 A0[8C7C]                		mov al, [0x7c00+buffer+2]
   115 00000064 26A20400                		mov [es:0x04], al
   116 00000068 26C60605002F            		mov byte [es:0x05], 0x2f
   117                                  		
   118 0000006E A0[8B7C]                		mov al, [0x7c00+buffer+1]
   119 00000071 26A20600                		mov [es:0x06], al
   120 00000075 26C60607002F            		mov byte [es:0x07], 0x2f
   121                                  		
   122 0000007B A0[8A7C]                		mov al, [0x7c00+buffer]
   123 0000007E 26A20800                		mov [es:0x08], al
   124 00000082 26C60609002F            		mov byte [es:0x09], 0x2f
   125                                  		
   126                                  		
   127                                  again:
   128 00000088 EBFE                    	jmp again ; 自己跳到自己 防止程序跑飞
   129                                  
   130 0000008A 0000000000              buffer	db 0, 0, 0, 0, 0 ;开辟5个字节的空间 这里位指令的冒号一般省略，这里buffer其实是表示第一个字节的地址 0x7c00+buffer 
   131                                  		
   132                                  current:
   133 0000008F 00<rep 16Fh>            		times 510-(current-start) db 0
   134 000001FE 55AA                    		db 0x55,0xaa
