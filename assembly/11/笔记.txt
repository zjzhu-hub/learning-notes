无符号数和有符号数
1111 1111 如果按照无符号数那就是255，如果按照有符号数那就是 -1

二进制 计算规则就是 加权计算 一般用计算器更快哈哈

如果二进制是有符号数 那第一位就是 符号位 1代表负数 0代表正数
具体有没有符号是自己决定的 看自己需求 可以按照无符号计算也可以按照符号计算 是不同的值


二进制负数
-1 等于 0 - 1 这个减法是2进制的 0 - 1 是没办法减的 需要一直借位 所以就是二进制全1 也可以代表255（如果是8位）也可以是 65535（16位）
-2 等于 0 -2 
00
10
1111 1110
结果转换为二进制就是 1111 1110 需要一直借位

sub 减法指令
语法
sub r/m, r/m/imm
过程
左操作数和右操作数相减，结果返回到做操作数
注意
两个操作数宽度必须一致，而且不能同时是内存地址

如
sub al, 35
sub dx, ax
sub dx, [0x2002]
sub byte [0x2002], 37
sub byte [0x2002], al

neg 指令 补码指令
可以吧一个数字变成负数，和正数
语法
neg r/m
过程
neg指令就是用0减去指令的操作数，在用结果替换给操作数的内容

如
neg al ; 如果al =  0000 1000（8） 那么执行这条指令后al等于 1111 1000（-8）。这里是负数 因为高位为1
neg ah ; 如果ah = 1100 0100 （-60） 那么执行这条指令ah等于 0011 1100 （60）。这里是正数 因为按照这个计算高位为0 代表正数
neg di ; 如果
neg byte [0x2002]


无符号乘法
mul
有符号乘法
imul
无符号除法
div
有符号除法
idiv

符号扩展指令
cbw ; 将AL中的有符号数扩展到AX
若AL=FD(-3)，则扩展后，AX=FFFD(-3)
cwde ;将AX中的有符号数扩展到EAX
若AX=FFFD(-3)，则扩展后EAX=FFFFFFFD(-3)
cdqe ;将EAX中的有符号数扩展到RAX
若EAX=FFFFFFFD(-3),则扩展后 RAX=FFFFFFFFFFFFFFFD(-3)

cwd ;将AX中的有符号数扩展到DX:AX
若AX=FFFD(-3), 则扩展后, DX=FFFF, AX=FFFD
cdq ; 将EAX中的有符号数扩展到EDX:EAX
若EAX=FFFFFFFD(-3), 则扩展后, EDX=FFFFFFFF, EAX=FFFFFFFD
cdo ; 将RAX中的有符号数扩展到RDX:RAX
若RAX=FFFFFFFFFFFFFFFD(-3), 则扩展后, RDX=FFFFFFFFFFFFFFFF, RAX=FFFFFFFFFFFFFFFD


