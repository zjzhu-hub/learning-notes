数据串的传输
movsb 按字节传输 mov是传输 s是string（串） b是byte
movsw 按字传输 mov是传输 s是string（串）w是word（字）

使用movsb 或者movsw前的准备工作
DS:SI 原始数据串的段地址：偏移地址 ds数据段寄存器，si是通用寄存器
ES:DI 目标位置的段地址：偏移地址   es是附加段寄存器 di是通用寄存器

传送的方向
正向传送（高地址方向）是指 原始位置DS:SI 位置传送到 ES:DI目标位置，低地址从高地址推进； movsb或者movsw 每执行一次 si和di自动加上传输的字节数
反向传送（低地址方向）是指 目标位置和原始位置从低地址推进；movsb或者movsw 每执行一次 si和di自动减去传输的字节数

为什么要递增或者递减si和di？
因为要指向下一个传送的位置，方便下一次传送 因为si和di的内容是偏移地址 相加或者相间可以指向下一个位置

8086的标志寄存器 FLAGS
这是一个16位的寄存器，每一位用作一个有特定含义的标志
bit 6 是零标志（zero flag）当处理器执行一条算数或者逻辑运算指令后 如果计算结果是零 这一bit设置为 1  否则设置为 0；通过这个bit 可以判断最近一次运算结果是零还是非零；这个bit 只读是处理器自动设置的
bit 10 是方向标志(direction flag) 这一位清零或者置一 就可以控制movsb和movsw的操作方向， 这个bit可以通过指令来设置的；cld 代表方向指令清零 表示正向 从低地址到高地址 这个是无操作数指令。相反的是std 指令置位（也就是置1） 表示 反向 从高地址到低地址

rep（repeat）前缀
为什么需要rep指令？因为movsw或者movsb 一次只能传输一个字 或者一个字节，或者说只能传送一次，如果希望指令指令反复的执行 需要加上 rep 前缀
rep movsw 代表重复执行movsw指令
上面的指令重复多少次呢？这里由寄存器cx指定


$ 代表当前行的汇编地址
$$ 代表当前段的起始汇编地址


bochs 里面查看第一条指令是jmp start 偏移地址是26 因为mytext里面就是26个字节 后面才是start
如何在bochs 查看 flags 寄存器状态 
在8086里面是叫flags 在32位处理器上 这个标志寄存器进行了扩展达到了32位 叫eflags，在64位叫做rflags
所以下面32位用info eflags查看 
<bochs:9> info eflags
eflags: 0x00000282: id vip vif ac vm rf nt IOPL=0 of df IF tf SF zf af pf cf
上面这一串文字是什么意思？
首先各个标志位是名称显示的，比如df是方向标志，zf是零标志
显示了标志的名称怎么知道他们是0还是1呢？很简单 小写的就是0 大写的就是1 。 如：zf=0 ，ZF=1 

下面这里loop循环指令
digit:
	loop digit

loop指令执行流程
将寄存器cx的内容-1
如果cx的内容不为零，转移到指定的位置处（digit）执行，否则顺序执行后面的指令
在loop执行执行前需要吧cx寄存器赋值 不然没办法循环

bx(base address register) 基址寄存器
寄存器BX在设计之初就是用来提供数据访问的基地址
在8086寄存器，如果要使用寄存器来提供偏移地址，只能使用BX，SI，DI，BP，不能使用其他寄存器也就是下面指令是非法的
mov [ax], dl
mov [dx], bl
其中[] 一定要加 不然就是mov 值给寄存器了
mov [bx] dl 这个是正确写法，先从寄存器bx取出偏移地址，然后从段寄存器ds左移四位的内容相加形成物理地址访问内存，然后将dl的数位写入到指定的内存地址

在设计8086处理器每个指令的用处
AX是累加器（Accumulator），与他有关的指令还会做指令长度上的优化（优化后较短）
CX是计数器（Counter）
DX是数据（Data）寄存器，除了作用为通用寄存器使用外，还专门用于和外设之间进行数据传送；
SI（Source Index）是源索引寄存器
DI（Destination Index）是目标索引寄存器，用于数据传输操作 如 movesb 和movsw 里面就是用的这个

inc（increase）递增指令 +1 
inc  r/m 给寄存器或者内存地址递增
inc al = al +1
inc di = di =1
inc byte [0x2002] = [0x2002] + 1

dec(decrement) 递减指令 -1
inc  r/m 给寄存器或者内存地址递减
dec al = al -1，如果al原本是6 执行后=5
dec di = di -1，如果di原本是8执行后=7
dec byte [0x2002] = [0x2002] -1 ，如果0x2002 内存地址里面原本是68 执行后 = 67


索引寄存器si （index register）或者叫变指寄存器 还有个是di
一般是循环的时候用的
在8086处理器只允许下面这几种组合
bx+si
bx+di
bp+si
bp+di

FLAGS 寄存器 第七位 SF（sign flag）位
很多算数或者逻辑运算时候如果结果最高位是0，SF置0，如果最高位是1 SF置1
0 表示正数
1 表示负数

如循环次数是si 4
mov si, 4
第一次执行dsc si 的时候 就是3 转换成二进制就是
0000 0000 0000 0011 第一位是0 SF置0
dsc si 到 -1 后 产生了借位 全部位变成了1 这个时候最高位是1 SF就会置1 退出循环
1111 1111 1111 1111
