     1 00000000 EB1A                    	jmp start
     2                                  
     3 00000002 4C076107620765076C-     mytext db 'L',0x07,'a',0x07,'b',0x07,'e',0x07,'l',0x07,' ',0x07,'o',0x07
     3 0000000B 0720076F07         
     4 00000010 660766077307650774-     	   db 'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07
     4 00000019 073A07             
     5                                  
     6                                  start:
     7 0000001C B8C007                  	mov ax, 0x7c0 ; 设置数据段的基地址
     8 0000001F 8ED8                    	mov ds, ax
     9                                  	
    10 00000021 B800B8                  	mov ax, 0xb800 ; 设置附加段的基地址
    11 00000024 8EC0                    	mov es, ax
    12                                  	
    13 00000026 FC                      	cld ; 传送的方向
    14 00000027 BE[0200]                	mov si,mytext ; 把文本的其实地址传送给si，因为主引导扇区是从07c0段的起始处开始加载的，所以mytext就是段内的偏移地址
    15 0000002A BF0000                  	mov di,0 ; 这意味这文本的传送是从显存的起始位置开始传送
    16 0000002D B90D00                  	mov cx,(start-mytext) / 2 ; 实际等于 13 因为Label offset: 加上颜色就是26个字节 / 2 = 13个字，这里为什么start-mytext 因为这些数据刚好加在标号start和mytext之间
    17 00000030 F3A5                    	rep movsw ; rep代表重复传输字节或者字 movsw代表传输一个字，重复传输多少次呢？这里由寄存器cx指定，这里每次执行movsw之前需要检查寄存器cx的值，只有在cx的值不等于0的时候才执行，如果等于0则不执行 则离开这条指令继续往下执行
    18                                  	
    19                                  	
    20                                  	; 得到标号所代表的汇编地址
    21 00000032 B8[5D00]                	mov ax, number
    22                                  	 
    23                                  	; 分解各个数位
    24 00000035 89C3                    	mov bx, ax
    25 00000037 B90500                  	mov cx, 5 ; 循环次数
    26 0000003A BE0A00                  	mov si, 10 ; 除数
    27                                  
    28                                  digit:
    29 0000003D 31D2                    	xor dx,dx ; 异或操作清零
    30 0000003F F7F6                    	div si ; 这里由于除数是si寄存器 16 位，被除数必须是 32 位，由 DX:AX 组合提供： 高 16 位（被除数的高位部分）在 DX ，低 16 位（被除数的低位部分）在 AX。 最终结果商（quotient） → 存入 AX，余数（remainder）→DX
    31 00000041 8817                    	mov [bx], dl ; 保存数位 这里的bx是 number 5个字节的段内偏移地址，这条指令执行时先从寄存器bx取出偏移地址，然后从段寄存器ds左移四位的内容相加形成物理地址访问内存，然后将dl的数位写入到指定的内存地址。注意这个指令的[]是必须的 否则就是传送到寄存器bx中 而不是bx寄存器指向的内存地址处
    32 00000043 43                      	inc bx ; 这里相当于bx + 1 递增，可以理解为其他语言的i++？
    33 00000044 E2F7                    	loop digit
    34                                  
    35                                  	; 开始显示各个数位
    36                                  ;	mov cx, 5 ; 循环次数
    37                                  ;show:
    38                                  ;	dec bx ; 递减操作 -1，这里为什么是先-1呢？因为前面inc递增到了 = number + 5 这个是越界地址 最大是 0到 4，所以这里要修正过来不然会出现越界
    39                                  ;	mov al, [bx] ; 把bx的作为地址从内存中取出刚才的数位 传送到al中
    40                                  ;	add al, 0x30 ; 这里加上16进制30 因为要显示数字必须这样对应ASCII编码
    41                                  ;	mov ah, 04; 把立即数4传送到ah 颜色属性 黑底红字
    42                                  ;	mov [es:di], ax ; 把ax（刚刚生成的字符编码 高位ah(属性)+低位al（ASCII）组成的ax）传送到段寄存器es（显存的基地址位置），di（偏移地址）是一直递增的（movsw指令） 前面没有操作过 所以可以继续使用
    43                                  ;	add di, 2 ; di +2 指向下一个字的位置,为什么+2 不是+1 因为显示字符有2个字节  颜色+ASCII ah+al=ax 16位寄存器
    44                                  ;	loop show
    45                                  
    46                                  	;显示各个数位
    47 00000046 BB[5D00]                	mov bx, number ; number的首地址
    48 00000049 BE0400                  	mov si, 4 ; 循环次数 0-4 循环5次
    49                                  show:
    50 0000004C 8A00                    	mov al,[bx+si] ;这里拿bx就是number的汇编地址+si偏移地址取到字符，si相当于索引 写入到al寄存器
    51 0000004E 0430                    	add al, 0x30 ; ASCII 编码
    52 00000050 B404                    	mov ah, 0x04 ; 颜色属性
    53 00000052 268905                  	mov [es:di], ax ; 字符编码和颜色属性写入到es 附加段寄存器 di是偏移地址 这个值之前没有改过 可以继续用
    54 00000055 83C702                  	add di, 2 ; 跳转到下一个字
    55 00000058 4E                      	dec si ; 递减操作 -1 指向下一个数位
    56 00000059 79F1                    	jns show ; 这里是跳转指令，跳转的条件是flags寄存器的第7位 SF 为1时不跳转。算数或者逻辑运算时候如果结果最高位是0，SF置0，如果最高位是1 SF置1，这里到了最后会到-1 产生借位 会变成最高位全1 所以SF 置1 退出循环
    57                                  
    58                                  
    59 0000005B EBFE                    	jmp $ ; 这里要维护程序的执行所以jmp $ ,这里为什么是$ 因为$ 代表当前行的汇编地址 直接跳转到自身即可
    60                                  	
    61 0000005D 0000000000              number db 0, 0, 0, 0, 0
    62                                  
    63 00000062 00<rep 19Ch>            	times 510-($-$$) db 0 ; $-$$ 是nasm特有的记号， 这里第一个$代表当前行的地址，$$代表当前程序段的起始汇编地址 这里面是0 。 这里面$-$$ 就是当前行的汇编地址-起始汇编地址 就是这段汇编代码的长度 再用510-前面的字节数 就得到了需要重复的字数
    64                                  	
    65 000001FE 55AA                    	db 0x55,0xaa
