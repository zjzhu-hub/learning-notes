	jmp start

mytext db 'L',0x07,'a',0x07,'b',0x07,'e',0x07,'l',0x07,' ',0x07,'o',0x07
	   db 'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07

start:
	mov ax, 0x7c0 ; 设置数据段的基地址
	mov ds, ax
	
	mov ax, 0xb800 ; 设置附加段的基地址
	mov es, ax
	
	cld ; 传送的方向
	mov si,mytext ; 把文本的其实地址传送给si，因为主引导扇区是从07c0段的起始处开始加载的，所以mytext就是段内的偏移地址
	mov di,0 ; 这意味这文本的传送是从显存的起始位置开始传送
	mov cx,(start-mytext) / 2 ; 实际等于 13 因为Label offset: 加上颜色就是26个字节 / 2 = 13个字，这里为什么start-mytext 因为这些数据刚好加在标号start和mytext之间
	rep movsw ; rep代表重复传输字节或者字 movsw代表传输一个字，重复传输多少次呢？这里由寄存器cx指定，这里每次执行movsw之前需要检查寄存器cx的值，只有在cx的值不等于0的时候才执行，如果等于0则不执行 则离开这条指令继续往下执行
	
	
	; 得到标号所代表的汇编地址
	mov ax, number
	 
	; 分解各个数位
	mov bx, ax
	mov cx, 5 ; 循环次数
	mov si, 10 ; 除数

digit:
	xor dx,dx ; 异或操作清零
	div si ; 这里由于除数是si寄存器 16 位，被除数必须是 32 位，由 DX:AX 组合提供： 高 16 位（被除数的高位部分）在 DX ，低 16 位（被除数的低位部分）在 AX。 最终结果商（quotient） → 存入 AX，余数（remainder）→DX
	mov [bx], dl ; 保存数位 这里的bx是 number 5个字节的段内偏移地址，这条指令执行时先从寄存器bx取出偏移地址，然后从段寄存器ds左移四位的内容相加形成物理地址访问内存，然后将dl的数位写入到指定的内存地址。注意这个指令的[]是必须的 否则就是传送到寄存器bx中 而不是bx寄存器指向的内存地址处
	inc bx ; 这里相当于bx + 1 递增，可以理解为其他语言的i++？
	loop digit

	; 开始显示各个数位
;	mov cx, 5 ; 循环次数
;show:
;	dec bx ; 递减操作 -1，这里为什么是先-1呢？因为前面inc递增到了 = number + 5 这个是越界地址 最大是 0到 4，所以这里要修正过来不然会出现越界
;	mov al, [bx] ; 把bx的作为地址从内存中取出刚才的数位 传送到al中
;	add al, 0x30 ; 这里加上16进制30 因为要显示数字必须这样对应ASCII编码
;	mov ah, 04; 把立即数4传送到ah 颜色属性 黑底红字
;	mov [es:di], ax ; 把ax（刚刚生成的字符编码 高位ah(属性)+低位al（ASCII）组成的ax）传送到段寄存器es（显存的基地址位置），di（偏移地址）是一直递增的（movsw指令） 前面没有操作过 所以可以继续使用
;	add di, 2 ; di +2 指向下一个字的位置,为什么+2 不是+1 因为显示字符有2个字节  颜色+ASCII ah+al=ax 16位寄存器
;	loop show

	;显示各个数位
	mov bx, number ; number的首地址
	mov si, 4 ; 循环次数 0-4 循环5次
show:
	mov al,[bx+si] ;这里拿bx就是number的汇编地址+si偏移地址取到字符，si相当于索引 写入到al寄存器
	add al, 0x30 ; ASCII 编码
	mov ah, 0x04 ; 颜色属性
	mov [es:di], ax ; 字符编码和颜色属性写入到es 附加段寄存器 di是偏移地址 这个值之前没有改过 可以继续用
	add di, 2 ; 跳转到下一个字
	dec si ; 递减操作 -1 指向下一个数位
	jns show ; 这里是跳转指令，跳转的条件是flags寄存器的第7位 SF 为1时不跳转。算数或者逻辑运算时候如果结果最高位是0，SF置0，如果最高位是1 SF置1，这里到了最后会到-1 产生借位 会变成最高位全1 所以SF 置1 退出循环


	jmp $ ; 这里要维护程序的执行所以jmp $ ,这里为什么是$ 因为$ 代表当前行的汇编地址 直接跳转到自身即可
	
number db 0, 0, 0, 0, 0

	times 510-($-$$) db 0 ; $-$$ 是nasm特有的记号， 这里第一个$代表当前行的地址，$$代表当前程序段的起始汇编地址 这里面是0 。 这里面$-$$ 就是当前行的汇编地址-起始汇编地址 就是这段汇编代码的长度 再用510-前面的字节数 就得到了需要重复的字数
	
	db 0x55,0xaa